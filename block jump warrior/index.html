<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Side-Scrolling Platformer</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #f0f0f0;
      }
      canvas {
        border: 2px solid #000;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
      // Error handling
      window.onerror = function (message, source, lineno, colno, error) {
        console.error(
          "An error occurred:",
          message,
          "at",
          source,
          "line",
          lineno
        );
        alert("An error occurred. Please check the console for details.");
      };

      // Player logic
      let player;

      function initPlayer() {
        player = {
          x: 50,
          y: 200,
          width: 30,
          height: 50,
          speed: 5,
          velX: 0,
          velY: 0,
          jumpForce: -15,
          isJumping: false,
          health: 100,
          maxHealth: 100,
          isAttacking: false,
          attackCooldown: 0,
          attackDuration: 10,
          attackDamage: 20,
          facingRight: true,
          state: "idle",
          frameCount: 0,
          invincibilityFrames: 0,
          score: 0,
        };
      }

      function updatePlayer() {
        player.frameCount++;

        player.velX = 0;
        if (isMoveLeft()) {
          player.velX = -player.speed;
          player.facingRight = false;
          player.state = "running";
        } else if (isMoveRight()) {
          player.velX = player.speed;
          player.facingRight = true;
          player.state = "running";
        } else {
          player.state = "idle";
        }

        if (isJump() && !player.isJumping) {
          player.velY = player.jumpForce;
          player.isJumping = true;
          player.state = "jumping";
          playSound("jump");
        }

        if (isAttack() && !player.isAttacking && player.attackCooldown === 0) {
          player.isAttacking = true;
          player.attackCooldown = 30;
          player.state = "attacking";
          createAttackEffect(
            player.x + (player.facingRight ? player.width : 0),
            player.y + player.height / 2
          );
          playSound("attack");
        }

        if (player.attackCooldown > 0) player.attackCooldown--;
        if (player.isAttacking) {
          player.attackDuration--;
          if (player.attackDuration <= 0) {
            player.isAttacking = false;
            player.attackDuration = 10;
          }
        }

        player.velY += gravity;

        player.x += player.velX;
        player.y += player.velY;

        player.x = Math.max(
          0,
          Math.min(player.x, LEVEL_WIDTH * TILE_SIZE - player.width)
        );

        if (player.invincibilityFrames > 0) {
          player.invincibilityFrames--;
        }

        if (player.frameCount % 60 === 0 && player.health < player.maxHealth) {
          player.health = Math.min(player.health + 1, player.maxHealth);
        }
      }

      function damagePlayer(amount) {
        if (player.invincibilityFrames === 0) {
          player.health -= amount;
          player.invincibilityFrames = 60;
          createDamageEffect(
            player.x + player.width / 2,
            player.y + player.height / 2
          );
          playSound("hurt");

          if (player.health <= 0) {
            gameOver();
          }
        }
      }

      function healPlayer(amount) {
        player.health = Math.min(player.health + amount, player.maxHealth);
        createHealEffect(
          player.x + player.width / 2,
          player.y + player.height / 2
        );
        playSound("heal");
      }

      function getPlayerAttackBox() {
        if (player.facingRight) {
          return {
            x: player.x + player.width,
            y: player.y,
            width: 40,
            height: player.height,
          };
        } else {
          return {
            x: player.x - 40,
            y: player.y,
            width: 40,
            height: player.height,
          };
        }
      }

      function addScore(points) {
        player.score += points;
      }

      function playSound(soundName) {
        console.log(`Playing sound: ${soundName}`);
      }

      function createAttackEffect(x, y) {
        console.log(`Creating attack effect at (${x}, ${y})`);
      }

      function createDamageEffect(x, y) {
        console.log(`Creating damage effect at (${x}, ${y})`);
      }

      function createHealEffect(x, y) {
        console.log(`Creating heal effect at (${x}, ${y})`);
      }

      function gameOver() {
        console.log("Game Over");
      }

      // Input handling
      const keys = {};
      let gamepad = null;
      let touchControls = {};

      function setupInputHandlers() {
        window.addEventListener("keydown", handleKeyDown);
        window.addEventListener("keyup", handleKeyUp);

        window.addEventListener("gamepadconnected", connectGamepad);
        window.addEventListener("gamepaddisconnected", disconnectGamepad);

        if ("ontouchstart" in window) {
          setupTouchControls();
        }
      }

      function handleKeyDown(e) {
        keys[e.code] = true;
        if (
          [
            "ArrowUp",
            "ArrowDown",
            "ArrowLeft",
            "ArrowRight",
            "Space",
            "KeyX",
          ].includes(e.code)
        ) {
          e.preventDefault();
        }
      }

      function handleKeyUp(e) {
        keys[e.code] = false;
      }

      function connectGamepad(e) {
        gamepad = e.gamepad;
        console.log("Gamepad connected:", gamepad.id);
      }

      function disconnectGamepad(e) {
        gamepad = null;
        console.log("Gamepad disconnected");
      }

      function setupTouchControls() {
        const touchArea = document.createElement("div");
        touchArea.id = "touchControls";
        touchArea.style.position = "absolute";
        touchArea.style.bottom = "10px";
        touchArea.style.left = "10px";
        touchArea.style.right = "10px";
        touchArea.style.height = "100px";
        document.body.appendChild(touchArea);

        const buttons = [
          { id: "left", text: "←", x: "10%" },
          { id: "right", text: "→", x: "30%" },
          { id: "jump", text: "Jump", x: "70%" },
          { id: "attack", text: "Attack", x: "90%" },
        ];

        buttons.forEach((btn) => {
          const button = document.createElement("button");
          button.id = btn.id;
          button.textContent = btn.text;
          button.style.position = "absolute";
          button.style.left = btn.x;
          button.style.bottom = "10px";
          touchArea.appendChild(button);

          button.addEventListener("touchstart", () => {
            touchControls[btn.id] = true;
          });
          button.addEventListener("touchend", () => {
            touchControls[btn.id] = false;
          });
        });
      }

      function updateInputState() {
        if (gamepad) {
          gamepad = navigator.getGamepads()[gamepad.index];
        }
      }

      function isKeyDown(keyCode) {
        return keys[keyCode] === true;
      }

      function isKeyUp(keyCode) {
        return keys[keyCode] === false || keys[keyCode] === undefined;
      }

      function isButtonPressed(button) {
        if (gamepad) {
          return gamepad.buttons[button].pressed;
        }
        return false;
      }

      function getAxisValue(axis) {
        if (gamepad) {
          return gamepad.axes[axis];
        }
        return 0;
      }

      function isMoveLeft() {
        return (
          isKeyDown("ArrowLeft") ||
          isButtonPressed(14) ||
          (gamepad && getAxisValue(0) < -0.5) ||
          touchControls.left
        );
      }

      function isMoveRight() {
        return (
          isKeyDown("ArrowRight") ||
          isButtonPressed(15) ||
          (gamepad && getAxisValue(0) > 0.5) ||
          touchControls.right
        );
      }

      function isJump() {
        return isKeyDown("Space") || isButtonPressed(0) || touchControls.jump;
      }

      function isAttack() {
        return isKeyDown("KeyX") || isButtonPressed(2) || touchControls.attack;
      }

      function isPaused() {
        return isKeyDown("Escape") || isButtonPressed(9);
      }

      setupInputHandlers();

      // Level generation
      const CASTLE_WIDTH = 5;
      const CASTLE_HEIGHT = 5;

      const TILE_SIZE = 40;
      const GRID_HEIGHT = 10;
      const SCREENS_PER_LEVEL = 6;
      const SCREEN_WIDTH = 20;
      const LEVEL_WIDTH = SCREEN_WIDTH * SCREENS_PER_LEVEL;

      let level = [];

      function generateLevel() {
        for (let y = 0; y < GRID_HEIGHT; y++) {
          level[y] = new Array(LEVEL_WIDTH).fill(0);
        }

        for (let x = 0; x < LEVEL_WIDTH; x++) {
          level[GRID_HEIGHT - 1][x] = 1;
        }

        for (let screen = 0; screen < SCREENS_PER_LEVEL - 1; screen++) {
          const screenStart = screen * SCREEN_WIDTH;
          const screenEnd = (screen + 1) * SCREEN_WIDTH;

          const platformCount = 2 + Math.floor(Math.random() * 3);
          for (let i = 0; i < platformCount; i++) {
            const platformWidth = 3 + Math.floor(Math.random() * 4);
            const platformX =
              screenStart +
              Math.floor(Math.random() * (SCREEN_WIDTH - platformWidth));
            const platformY =
              GRID_HEIGHT - 2 - Math.floor(Math.random() * (GRID_HEIGHT - 4));

            for (let x = platformX; x < platformX + platformWidth; x++) {
              level[platformY][x] = 1;
            }
          }
        }

        const castleStart = LEVEL_WIDTH - CASTLE_WIDTH - 1;
        for (let y = GRID_HEIGHT - CASTLE_HEIGHT; y < GRID_HEIGHT; y++) {
          for (let x = castleStart; x < LEVEL_WIDTH; x++) {
            level[y][x] = 2;
          }
        }

        level[GRID_HEIGHT - 2][LEVEL_WIDTH - 1] = 3;
        level[GRID_HEIGHT - 3][LEVEL_WIDTH - 1] = 3;
      }

      function renderLevel(ctx, camera) {
        const startX = Math.floor(camera.x / TILE_SIZE);
        const endX = Math.min(startX + SCREEN_WIDTH + 1, LEVEL_WIDTH);

        for (let y = 0; y < GRID_HEIGHT; y++) {
          for (let x = startX; x < endX; x++) {
            const tileType = level[y][x];
            if (tileType !== 0) {
              let color;
              switch (tileType) {
                case 1:
                  color = "gray";
                  break;
                case 2:
                  color = "brown";
                  break;
                case 3:
                  color = "black";
                  break;
                default:
                  color = "purple";
              }
              ctx.fillStyle = color;
              ctx.fillRect(
                (x - startX) * TILE_SIZE,
                y * TILE_SIZE,
                TILE_SIZE,
                TILE_SIZE
              );
            }
          }
        }
      }

      function getTile(x, y) {
        if (x < 0 || x >= LEVEL_WIDTH || y < 0 || y >= GRID_HEIGHT) {
          return 1;
        }
        return level[y][x];
      }

      function isLevelComplete(playerX, playerY) {
        const playerTileX = Math.floor(playerX / TILE_SIZE);
        const playerTileY = Math.floor(playerY / TILE_SIZE);
        return level[playerTileY][playerTileX] === 3;
      }

      function getRandomSpawnPosition() {
        let x, y;
        do {
          x = Math.floor(Math.random() * LEVEL_WIDTH);
          y = GRID_HEIGHT - 2;
        } while (getTile(x, y) !== 0 || getTile(x, y + 1) === 0);

        return { x: x * TILE_SIZE, y: y * TILE_SIZE };
      }

      function isOnGround(x, y) {
        const tileX = Math.floor(x / TILE_SIZE);
        const tileY = Math.floor(y / TILE_SIZE);
        return getTile(tileX, tileY + 1) !== 0;
      }

      function getNearestFloor(x, y) {
        const startTileY = Math.floor(y / TILE_SIZE);
        for (let tileY = startTileY; tileY < GRID_HEIGHT; tileY++) {
          if (getTile(Math.floor(x / TILE_SIZE), tileY) !== 0) {
            return tileY * TILE_SIZE;
          }
        }
        return GRID_HEIGHT * TILE_SIZE;
      }

      // Enemy logic
      let enemies = [];

      class Enemy {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.width = 30;
          this.height = 50;
          this.speed = 2;
          this.velX = -this.speed;
          this.velY = 0;
          this.health = 60;
          this.maxHealth = 60;
          this.isAttacking = false;
          this.attackCooldown = 0;
          this.attackDuration = 20;
          this.attackDamage = 10;
          this.facingRight = false;
          this.state = "idle";
          this.frameCount = 0;
          this.detectionRange = 200;
          this.attackRange = 50;

          if (this.type === "fast") {
            this.speed = 3;
            this.health = this.maxHealth = 40;
            this.attackDamage = 5;
          } else if (this.type === "heavy") {
            this.speed = 1;
            this.health = this.maxHealth = 100;
            this.attackDamage = 20;
            this.width = 40;
            this.height = 60;
          }
        }

        update() {
          this.frameCount++;

          const distanceToPlayer = Math.abs(this.x - player.x);

          if (distanceToPlayer <= this.detectionRange) {
            this.velX = player.x < this.x ? -this.speed : this.speed;
            this.facingRight = this.velX > 0;
            this.state = "chasing";

            if (distanceToPlayer <= this.attackRange) {
              this.attack();
            }
          } else {
            if (this.frameCount % 120 === 0) {
              this.velX = -this.velX;
              this.facingRight = this.velX > 0;
            }
            this.state = "patrolling";
          }

          this.x += this.velX;

          this.velY += gravity;
          this.y += this.velY;

          if (this.attackCooldown > 0) {
            this.attackCooldown--;
          }
          if (this.isAttacking) {
            this.attackDuration--;
            if (this.attackDuration <= 0) {
              this.isAttacking = false;
              this.attackDuration = 20;
            }
          }

          this.x = Math.max(
            0,
            Math.min(this.x, LEVEL_WIDTH * TILE_SIZE - this.width)
          );
        }

        attack() {
          if (!this.isAttacking && this.attackCooldown === 0) {
            this.isAttacking = true;
            this.attackCooldown = 60;
            this.state = "attacking";
            createAttackEffect(
              this.x + (this.facingRight ? this.width : 0),
              this.y + this.height / 2
            );
            playSound("enemyAttack");
          }
        }

        takeDamage(amount) {
          this.health -= amount;
          createDamageEffect(this.x + this.width / 2, this.y + this.height / 2);
          playSound("enemyHurt");

          if (this.health <= 0) {
            this.die();
          }
        }

        die() {
          enemies = enemies.filter((e) => e !== this);
          createDeathEffect(this.x + this.width / 2, this.y + this.height / 2);
          playSound("enemyDeath");
          addScore(this.type === "heavy" ? 20 : 10);
        }
      }

      function spawnEnemy() {
        if (enemies.length < MAX_ENEMIES) {
          let x = Math.random() * LEVEL_WIDTH * TILE_SIZE;
          let y = 0;
          for (let i = 0; i < GRID_HEIGHT; i++) {
            if (getTile(Math.floor(x / TILE_SIZE), i) === 1) {
              y = i * TILE_SIZE - TILE_SIZE;
              break;
            }
          }
          const type =
            Math.random() < 0.7
              ? "normal"
              : Math.random() < 0.5
              ? "fast"
              : "heavy";
          enemies.push(new Enemy(x, y, type));
        }
      }

      function updateEnemies() {
        enemies.forEach((enemy) => enemy.update());
      }

      function getEnemyAttackBoxes() {
        return enemies
          .filter((e) => e.isAttacking)
          .map((e) => {
            return {
              x: e.facingRight ? e.x + e.width : e.x - 20,
              y: e.y,
              width: 20,
              height: e.height,
              damage: e.attackDamage,
            };
          });
      }

      function playSound(soundName) {
        console.log(`Playing sound: ${soundName}`);
      }

      function createAttackEffect(x, y) {
        console.log(`Creating enemy attack effect at (${x}, ${y})`);
      }

      function createDamageEffect(x, y) {
        console.log(`Creating enemy damage effect at (${x}, ${y})`);
      }

      function createDeathEffect(x, y) {
        console.log(`Creating enemy death effect at (${x}, ${y})`);
      }

      function addScore(points) {
        console.log(`Adding ${points} to score`);
      }

      const MAX_ENEMIES = 3;

      // Collision detection
      const COLLISION_PADDING = 1;

      function checkCollisions() {
        checkPlayerLevelCollisions();
        checkEnemyLevelCollisions();
        checkPlayerEnemyCollisions();
        checkProjectileCollisions();
      }

      function checkPlayerLevelCollisions() {
        const left = Math.floor(player.x / TILE_SIZE);
        const right = Math.floor((player.x + player.width) / TILE_SIZE);
        const top = Math.floor(player.y / TILE_SIZE);
        const bottom = Math.floor((player.y + player.height) / TILE_SIZE);

        player.isJumping = true;

        for (let y = top; y <= bottom; y++) {
          for (let x = left; x <= right; x++) {
            if (getTile(x, y) === 1) {
              const tileTop = y * TILE_SIZE;
              const tileBottom = tileTop + TILE_SIZE;
              const tileLeft = x * TILE_SIZE;
              const tileRight = tileLeft + TILE_SIZE;

              if (
                player.velY > 0 &&
                player.y + player.height > tileTop &&
                player.y < tileTop
              ) {
                player.y = tileTop - player.height - COLLISION_PADDING;
                player.velY = 0;
                player.isJumping = false;
              } else if (
                player.velY < 0 &&
                player.y < tileBottom &&
                player.y + player.height > tileBottom
              ) {
                player.y = tileBottom + COLLISION_PADDING;
                player.velY = 0;
              }
              if (
                player.velX < 0 &&
                player.x < tileRight &&
                player.x + player.width > tileRight
              ) {
                player.x = tileRight + COLLISION_PADDING;
              } else if (
                player.velX > 0 &&
                player.x + player.width > tileLeft &&
                player.x < tileLeft
              ) {
                player.x = tileLeft - player.width - COLLISION_PADDING;
              }
            }
          }
        }

        player.x = Math.max(
          0,
          Math.min(player.x, LEVEL_WIDTH * TILE_SIZE - player.width)
        );
        if (player.y > GRID_HEIGHT * TILE_SIZE) {
          damagePlayer(player.health);
        }
      }

      function checkEnemyLevelCollisions() {
        enemies.forEach((enemy) => {
          const left = Math.floor(enemy.x / TILE_SIZE);
          const right = Math.floor((enemy.x + enemy.width) / TILE_SIZE);
          const top = Math.floor(enemy.y / TILE_SIZE);
          const bottom = Math.floor((enemy.y + enemy.height) / TILE_SIZE);

          for (let y = top; y <= bottom; y++) {
            for (let x = left; x <= right; x++) {
              if (getTile(x, y) === 1) {
                const tileTop = y * TILE_SIZE;
                const tileBottom = tileTop + TILE_SIZE;
                const tileLeft = x * TILE_SIZE;
                const tileRight = tileLeft + TILE_SIZE;

                if (
                  enemy.velY > 0 &&
                  enemy.y + enemy.height > tileTop &&
                  enemy.y < tileTop
                ) {
                  enemy.y = tileTop - enemy.height - COLLISION_PADDING;
                  enemy.velY = 0;
                } else if (
                  enemy.velY < 0 &&
                  enemy.y < tileBottom &&
                  enemy.y + enemy.height > tileBottom
                ) {
                  enemy.y = tileBottom + COLLISION_PADDING;
                  enemy.velY = 0;
                }
                if (enemy.x < tileRight && enemy.x + enemy.width > tileLeft) {
                  enemy.velX = -enemy.velX;
                  enemy.facingRight = !enemy.facingRight;
                }
              }
            }
          }

          enemy.x = Math.max(
            0,
            Math.min(enemy.x, LEVEL_WIDTH * TILE_SIZE - enemy.width)
          );
          if (enemy.y > GRID_HEIGHT * TILE_SIZE) {
            enemy.health = 0;
          }
        });
      }

      function checkPlayerEnemyCollisions() {
        const playerAttackBox = getPlayerAttackBox();

        enemies.forEach((enemy) => {
          if (player.isAttacking && boxCollision(playerAttackBox, enemy)) {
            enemy.takeDamage(player.attackDamage);
          }

          if (!player.isAttacking && boxCollision(player, enemy)) {
            damagePlayer(10);
            pushBack(player, enemy);
          }
        });

        getEnemyAttackBoxes().forEach((attackBox) => {
          if (boxCollision(attackBox, player)) {
            damagePlayer(attackBox.damage);
          }
        });
      }

      function checkProjectileCollisions() {
        console.log("Projectile collisions not implemented yet");
      }

      function boxCollision(a, b) {
        return (
          a.x < b.x + b.width &&
          a.x + a.width > b.x &&
          a.y < b.y + b.height &&
          a.y + a.height > b.y
        );
      }

      function pushBack(entity1, entity2) {
        const pushForce = 5;
        const dx = entity1.x - entity2.x;
        const dy = entity1.y - entity2.y;
        const angle = Math.atan2(dy, dx);

        entity1.x += Math.cos(angle) * pushForce;
        entity1.y += Math.sin(angle) * pushForce;
      }

      function pointInBox(x, y, box) {
        return (
          x >= box.x &&
          x <= box.x + box.width &&
          y >= box.y &&
          y <= box.y + box.height
        );
      }

      // Rendering
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-camera.x, 0);

        renderBackground();
        renderLevel(ctx, camera);
        renderPlayer();
        renderEnemies();
        updateAndRenderParticles();

        ctx.restore();

        renderUI();
      }

      function renderBackground() {
        const backgroundImage = new Image();
        backgroundImage.src = "path/to/your/background.png";

        const parallaxFactor = 0.5;
        const backgroundX = -camera.x * parallaxFactor;

        ctx.drawImage(
          backgroundImage,
          backgroundX,
          0,
          canvas.width,
          canvas.height
        );
        ctx.drawImage(
          backgroundImage,
          backgroundX + canvas.width,
          0,
          canvas.width,
          canvas.height
        );
      }

      function renderPlayer() {
        ctx.fillStyle = "blue";
        ctx.fillRect(
          player.x - camera.x,
          player.y,
          player.width,
          player.height
        );

        if (player.isAttacking) {
          ctx.fillStyle = "yellow";
          if (player.facingRight) {
            ctx.fillRect(
              player.x + player.width - camera.x,
              player.y + 10,
              40,
              30
            );
          } else {
            ctx.fillRect(player.x - 40 - camera.x, player.y + 10, 40, 30);
          }
        }

        renderHealthBar(
          player.x - camera.x,
          player.y - 20,
          player.width,
          5,
          player.maxHealth,
          player.health
        );
      }

      function renderEnemies() {
        enemies.forEach((enemy) => {
          ctx.fillStyle = "red";
          ctx.fillRect(enemy.x - camera.x, enemy.y, enemy.width, enemy.height);

          if (enemy.isAttacking) {
            ctx.fillStyle = "orange";
            if (enemy.facingRight) {
              ctx.fillRect(
                enemy.x + enemy.width - camera.x,
                enemy.y + 10,
                20,
                30
              );
            } else {
              ctx.fillRect(enemy.x - 20 - camera.x, enemy.y + 10, 20, 30);
            }
          }

          renderHealthBar(
            enemy.x - camera.x,
            enemy.y - 10,
            enemy.width,
            5,
            enemy.maxHealth,
            enemy.health
          );
        });
      }

      function renderUI() {
        ctx.fillStyle = "black";
        ctx.font = "20px Arial";
        ctx.fillText(`Health: ${player.health}`, 10, 30);
        ctx.fillText(`Enemies: ${enemies.length}`, 10, 60);
        const progress = (player.x / (LEVEL_WIDTH * TILE_SIZE)) * 100;
        ctx.fillText(`Progress: ${progress.toFixed(1)}%`, 10, 90);
        renderMiniMap();
      }

      function renderMiniMap() {
        const mapWidth = 150;
        const mapHeight = 50;
        const mapX = canvas.width - mapWidth - 10;
        const mapY = 10;

        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(mapX, mapY, mapWidth, mapHeight);

        const playerMapX =
          mapX + (player.x / (LEVEL_WIDTH * TILE_SIZE)) * mapWidth;
        ctx.fillStyle = "blue";
        ctx.fillRect(playerMapX, mapY + mapHeight / 2, 4, 4);

        const castleMapX = mapX + mapWidth - 5;
        ctx.fillStyle = "gray";
        ctx.fillRect(castleMapX, mapY, 5, mapHeight);
      }

      function renderHealthBar(x, y, width, height, maxHealth, currentHealth) {
        const healthPercentage = currentHealth / maxHealth;
        ctx.fillStyle = "red";
        ctx.fillRect(x, y, width, height);
        ctx.fillStyle = "green";
        ctx.fillRect(x, y, width * healthPercentage, height);
        ctx.strokeStyle = "black";
        ctx.strokeRect(x, y, width, height);
      }

      let particles = [];

      function createParticle(x, y, color, lifespan = 30) {
        return {
          x,
          y,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 2) * 3,
          color,
          lifespan,
        };
      }

      function updateAndRenderParticles() {
        particles = particles.filter((p) => p.lifespan > 0);
        particles.forEach((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += gravity * 0.1;
          p.lifespan--;

          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - camera.x, p.y, 3, 3);
        });
      }

      function createAttackEffect(x, y) {
        for (let i = 0; i < 20; i++) {
          particles.push(createParticle(x, y, "yellow"));
        }
      }

      function createDamageEffect(x, y) {
        for (let i = 0; i < 15; i++) {
          particles.push(createParticle(x, y, "red"));
        }
      }

      function createHealEffect(x, y) {
        for (let i = 0; i < 15; i++) {
          particles.push(createParticle(x, y, "green"));
        }
      }

      function showLevelCompleteScreen() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Level Complete!", canvas.width / 2, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText(
          "Press ENTER to start next level",
          canvas.width / 2,
          canvas.height / 2 + 40
        );
      }

      function showGameOverScreen() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText(
          "Press ENTER to restart",
          canvas.width / 2,
          canvas.height / 2 + 40
        );
      }

      // Game main logic
      const SCREENS_PER_LEVEL = 6;
      const SCREEN_WIDTH = canvas.width / TILE_SIZE;
      const ENEMY_SPAWN_INTERVAL = 5000;
      const gravity = 0.8;

      const camera = {
        x: 0,
        y: 0,
      };

      let lastEnemySpawnTime = 0;
      let gameState = "playing";

      function init() {
        console.log("Initializing game...");
        try {
          initPlayer();
          generateLevel();
          spawnEnemy();
          gameState = "playing";
          console.log("Game initialized successfully");
        } catch (error) {
          console.error("Error during game initialization:", error);
          alert(
            "Failed to initialize game. Please check the console for details."
          );
        }
      }

      function gameLoop(timestamp) {
        try {
          update(timestamp);
          render();

          if (gameState === "playing") {
            requestAnimationFrame(gameLoop);
          } else if (gameState === "levelComplete") {
            showLevelCompleteScreen();
          } else if (gameState === "gameOver") {
            showGameOverScreen();
          }
        } catch (error) {
          console.error("Error in game loop:", error);
          alert(
            "An error occurred in the game loop. Please check the console for details."
          );
        }
      }

      function update(timestamp) {
        if (gameState !== "playing") return;

        updateInputState();
        updatePlayer();
        updateCamera();
        checkCollisions();

        if (timestamp - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL) {
          spawnEnemy();
          lastEnemySpawnTime = timestamp;
        }

        updateEnemies();

        if (isLevelComplete(player.x, player.y)) {
          gameState = "levelComplete";
        }

        if (player.health <= 0) {
          gameState = "gameOver";
        }
      }

      function updateCamera() {
        camera.x = Math.max(
          0,
          Math.min(
            player.x - canvas.width / 2,
            LEVEL_WIDTH * TILE_SIZE - canvas.width
          )
        );
      }

      function resetGame() {
        console.log("Resetting game...");
        player.x = 50;
        player.y = 200;
        player.health = 100;
        enemies.length = 0;
        generateLevel();
        spawnEnemy();
        gameState = "playing";
        requestAnimationFrame(gameLoop);
      }

      window.addEventListener("keydown", (e) => {
        if (
          e.code === "Enter" &&
          (gameState === "levelComplete" || gameState === "gameOver")
        ) {
          resetGame();
        }
      });

      init();
      console.log("Starting game loop...");
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
